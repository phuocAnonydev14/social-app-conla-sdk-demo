"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.callDataCost = exports.fillSignAndPack = exports.fillAndSign = exports.fillAndPack = exports.fillUserOp = exports.fillUserOpDefaults = exports.resolveHexlify = exports.deepHexlify = exports.rethrowError = exports.decodeErrorReason = exports.getUserOpHash = exports.encodeUserOp = exports.unpackUserOp = exports.packUserOp = exports.unpackPaymasterAndData = exports.packValidationData = exports.mergeValidationData = exports.mergeValidationDataValues = exports.parseValidationData = exports.SIG_VALIDATION_FAILED = exports.maxUint48 = exports.packPaymasterData = exports.unpackUint = exports.packUint = exports.unpackAccountGasLimits = exports.packAccountGasLimits = exports.DefaultsForUserOp = exports.AddressZero = void 0;
const utils_1 = require("ethers/lib/utils");
const IEntryPoint_json_1 = require("@account-abstraction/contracts/artifacts/IEntryPoint.json");
const ethers_1 = require("ethers");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)("aa.utils");
// UserOperation is the first parameter of getUserOpHash
const getUserOpHashMethod = "getUserOpHash";
const PackedUserOpType = (_a = IEntryPoint_json_1.abi.find((entry) => entry.name === getUserOpHashMethod)) === null || _a === void 0 ? void 0 : _a.inputs[0];
if (PackedUserOpType == null) {
    throw new Error(`unable to find method ${getUserOpHashMethod} in EP ${IEntryPoint_json_1.abi
        .filter((x) => x.type === "function")
        .map((x) => x.name)
        .join(",")}`);
}
exports.AddressZero = ethers_1.ethers.constants.AddressZero;
exports.DefaultsForUserOp = {
    sender: exports.AddressZero,
    nonce: 0,
    initCode: "0x",
    callData: "0x",
    callGasLimit: 0,
    verificationGasLimit: 150000,
    preVerificationGas: 21000,
    maxFeePerGas: 0,
    maxPriorityFeePerGas: 1e9,
    paymaster: exports.AddressZero,
    paymasterData: "0x",
    paymasterVerificationGasLimit: 3e5,
    paymasterPostOpGasLimit: 0,
    signature: "0x",
};
// todo: remove this wrapper method?
function packAccountGasLimits(validationGasLimit, callGasLimit) {
    return packUint(validationGasLimit, callGasLimit);
}
exports.packAccountGasLimits = packAccountGasLimits;
function unpackAccountGasLimits(accountGasLimits) {
    const [verificationGasLimit, callGasLimit] = unpackUint(accountGasLimits);
    return { verificationGasLimit, callGasLimit };
}
exports.unpackAccountGasLimits = unpackAccountGasLimits;
function packUint(high128, low128) {
    return (0, utils_1.hexZeroPad)(ethers_1.BigNumber.from(high128).shl(128).add(low128).toHexString(), 32);
}
exports.packUint = packUint;
function unpackUint(packed) {
    const packedNumber = ethers_1.BigNumber.from(packed);
    return [
        packedNumber.shr(128),
        packedNumber.and(ethers_1.BigNumber.from(1).shl(128).sub(1)),
    ];
}
exports.unpackUint = unpackUint;
function packPaymasterData(paymaster, paymasterVerificationGasLimit, postOpGasLimit, paymasterData) {
    return ethers_1.ethers.utils.hexConcat([
        paymaster,
        packUint(paymasterVerificationGasLimit, postOpGasLimit),
        paymasterData !== null && paymasterData !== void 0 ? paymasterData : "0x",
    ]);
}
exports.packPaymasterData = packPaymasterData;
exports.maxUint48 = 2 ** 48 - 1;
exports.SIG_VALIDATION_FAILED = (0, utils_1.hexZeroPad)("0x01", 20);
/**
 * parse validationData as returned from validateUserOp or validatePaymasterUserOp into ValidationData struct
 * @param validationData
 */
function parseValidationData(validationData) {
    const data = (0, utils_1.hexZeroPad)(ethers_1.BigNumber.from(validationData).toHexString(), 32);
    // string offsets start from left (msb)
    const aggregator = (0, utils_1.hexDataSlice)(data, 32 - 20);
    let validUntil = parseInt((0, utils_1.hexDataSlice)(data, 32 - 26, 32 - 20));
    if (validUntil === 0)
        validUntil = exports.maxUint48;
    const validAfter = parseInt((0, utils_1.hexDataSlice)(data, 0, 6));
    return {
        aggregator,
        validAfter,
        validUntil,
    };
}
exports.parseValidationData = parseValidationData;
function mergeValidationDataValues(accountValidationData, paymasterValidationData) {
    return mergeValidationData(parseValidationData(accountValidationData), parseValidationData(paymasterValidationData));
}
exports.mergeValidationDataValues = mergeValidationDataValues;
/**
 * merge validationData structure returned by paymaster and account
 * @param accountValidationData returned from validateUserOp
 * @param paymasterValidationData returned from validatePaymasterUserOp
 */
function mergeValidationData(accountValidationData, paymasterValidationData) {
    return {
        aggregator: paymasterValidationData.aggregator !== exports.AddressZero
            ? exports.SIG_VALIDATION_FAILED
            : accountValidationData.aggregator,
        validAfter: Math.max(accountValidationData.validAfter, paymasterValidationData.validAfter),
        validUntil: Math.min(accountValidationData.validUntil, paymasterValidationData.validUntil),
    };
}
exports.mergeValidationData = mergeValidationData;
function packValidationData(validationData) {
    var _a, _b;
    return ethers_1.BigNumber.from((_a = validationData.validAfter) !== null && _a !== void 0 ? _a : 0)
        .shl(48)
        .add((_b = validationData.validUntil) !== null && _b !== void 0 ? _b : 0)
        .shl(160)
        .add(validationData.aggregator);
}
exports.packValidationData = packValidationData;
function unpackPaymasterAndData(paymasterAndData) {
    if (paymasterAndData.length <= 2)
        return null;
    if ((0, utils_1.hexDataLength)(paymasterAndData) < 52) {
        // if length is non-zero, then must at least host paymaster address and gas-limits
        throw new Error(`invalid PaymasterAndData: ${paymasterAndData}`);
    }
    const [paymasterVerificationGas, postOpGasLimit] = unpackUint((0, utils_1.hexDataSlice)(paymasterAndData, 20, 52));
    return {
        paymaster: (0, utils_1.hexDataSlice)(paymasterAndData, 0, 20),
        paymasterVerificationGas,
        postOpGasLimit,
        paymasterData: (0, utils_1.hexDataSlice)(paymasterAndData, 52),
    };
}
exports.unpackPaymasterAndData = unpackPaymasterAndData;
function packUserOp(op) {
    var _a;
    let paymasterAndData;
    if (op.paymaster == null) {
        paymasterAndData = "0x";
    }
    else {
        if (op.paymasterVerificationGasLimit == null ||
            op.paymasterPostOpGasLimit == null) {
            throw new Error("paymaster with no gas limits");
        }
        paymasterAndData = packPaymasterData(op.paymaster, op.paymasterVerificationGasLimit, op.paymasterPostOpGasLimit, op.paymasterData);
    }
    return {
        sender: op.sender,
        nonce: ethers_1.BigNumber.from(op.nonce).toHexString(),
        initCode: op.factory == null ? "0x" : (0, utils_1.hexConcat)([op.factory, (_a = op.factoryData) !== null && _a !== void 0 ? _a : ""]),
        callData: op.callData,
        accountGasLimits: packUint(op.verificationGasLimit, op.callGasLimit),
        preVerificationGas: ethers_1.BigNumber.from(op.preVerificationGas).toHexString(),
        gasFees: packUint(op.maxPriorityFeePerGas, op.maxFeePerGas),
        paymasterAndData,
        signature: op.signature,
    };
}
exports.packUserOp = packUserOp;
function unpackUserOp(packed) {
    const [verificationGasLimit, callGasLimit] = unpackUint(packed.accountGasLimits);
    const [maxPriorityFeePerGas, maxFeePerGas] = unpackUint(packed.gasFees);
    let ret = {
        sender: packed.sender,
        nonce: packed.nonce,
        callData: packed.callData,
        preVerificationGas: packed.preVerificationGas,
        verificationGasLimit,
        callGasLimit,
        maxFeePerGas,
        maxPriorityFeePerGas,
        signature: packed.signature,
    };
    if (packed.initCode != null && packed.initCode.length > 2) {
        const factory = (0, utils_1.hexDataSlice)(packed.initCode, 0, 20);
        const factoryData = (0, utils_1.hexDataSlice)(packed.initCode, 20);
        ret = Object.assign(Object.assign({}, ret), { factory,
            factoryData });
    }
    const pmData = unpackPaymasterAndData(packed.paymasterAndData);
    if (pmData != null) {
        ret = Object.assign(Object.assign({}, ret), { paymaster: pmData.paymaster, paymasterVerificationGasLimit: pmData.paymasterVerificationGas, paymasterPostOpGasLimit: pmData.postOpGasLimit, paymasterData: pmData.paymasterData });
    }
    return ret;
}
exports.unpackUserOp = unpackUserOp;
/**
 * abi-encode the userOperation
 * @param op a PackedUserOp
 * @param forSignature "true" if the hash is needed to calculate the getUserOpHash()
 *  "false" to pack entire UserOp, for calculating the calldata cost of putting it on-chain.
 */
function encodeUserOp(op1, forSignature = true) {
    // if "op" is unpacked UserOperation, then pack it first, before we ABI-encode it.
    let op;
    if ("callGasLimit" in op1) {
        op = packUserOp(op1);
    }
    else {
        op = op1;
    }
    if (forSignature) {
        return utils_1.defaultAbiCoder.encode([
            "address",
            "uint256",
            "bytes32",
            "bytes32",
            "bytes32",
            "uint256",
            "bytes32",
            "bytes32",
        ], [
            op.sender,
            op.nonce,
            (0, utils_1.keccak256)(op.initCode),
            (0, utils_1.keccak256)(op.callData),
            op.accountGasLimits,
            op.preVerificationGas,
            op.gasFees,
            (0, utils_1.keccak256)(op.paymasterAndData),
        ]);
    }
    else {
        // for the purpose of calculating gas cost encode also signature (and no keccak of bytes)
        return utils_1.defaultAbiCoder.encode([
            "address",
            "uint256",
            "bytes",
            "bytes",
            "bytes32",
            "uint256",
            "bytes32",
            "bytes",
            "bytes",
        ], [
            op.sender,
            op.nonce,
            op.initCode,
            op.callData,
            op.accountGasLimits,
            op.preVerificationGas,
            op.gasFees,
            op.paymasterAndData,
            op.signature,
        ]);
    }
}
exports.encodeUserOp = encodeUserOp;
/**
 * calculate the userOpHash of a given userOperation.
 * The userOpHash is a hash of all UserOperation fields, except the "signature" field.
 * The entryPoint uses this value in the emitted UserOperationEvent.
 * A wallet may use this value as the hash to sign (the SampleWallet uses this method)
 * @param op
 * @param entryPoint
 * @param chainId
 */
function getUserOpHash(op, entryPoint, chainId) {
    const userOpHash = (0, utils_1.keccak256)(encodeUserOp(op, true));
    const enc = utils_1.defaultAbiCoder.encode(["bytes32", "address", "uint256"], [userOpHash, entryPoint, chainId]);
    return (0, utils_1.keccak256)(enc);
}
exports.getUserOpHash = getUserOpHash;
const ErrorSig = (0, utils_1.keccak256)(Buffer.from("Error(string)")).slice(0, 10); // 0x08c379a0
const FailedOpSig = (0, utils_1.keccak256)(Buffer.from("FailedOp(uint256,string)")).slice(0, 10); // 0x220266b6
/**
 * decode bytes thrown by revert as Error(message) or FailedOp(opIndex,paymaster,message)
 */
function decodeErrorReason(error) {
    var _a;
    if (typeof error !== "string") {
        const err = error;
        error = ((_a = err.data) !== null && _a !== void 0 ? _a : err.error.data);
    }
    debug("decoding", error);
    if (error.startsWith(ErrorSig)) {
        const [message] = utils_1.defaultAbiCoder.decode(["string"], "0x" + error.substring(10));
        return { message };
    }
    else if (error.startsWith(FailedOpSig)) {
        let [opIndex, message] = utils_1.defaultAbiCoder.decode(["uint256", "string"], "0x" + error.substring(10));
        message = `FailedOp: ${message}`;
        return {
            message,
            opIndex,
        };
    }
}
exports.decodeErrorReason = decodeErrorReason;
/**
 * update thrown Error object with our custom FailedOp message, and re-throw it.
 * updated both "message" and inner encoded "data"
 * tested on geth, hardhat-node
 * usage: entryPoint.handleOps().catch(decodeError)
 */
function rethrowError(e) {
    let error = e;
    let parent = e;
    if ((error === null || error === void 0 ? void 0 : error.error) != null) {
        error = error.error;
    }
    while ((error === null || error === void 0 ? void 0 : error.data) != null) {
        parent = error;
        error = error.data;
    }
    const decoded = typeof error === "string" && error.length > 2
        ? decodeErrorReason(error)
        : undefined;
    if (decoded != null) {
        e.message = decoded.message;
        if (decoded.opIndex != null) {
            // helper for chai: convert our FailedOp error into "Error(msg)"
            const errorWithMsg = (0, utils_1.hexConcat)([
                ErrorSig,
                utils_1.defaultAbiCoder.encode(["string"], [decoded.message]),
            ]);
            // modify in-place the error object:
            parent.data = errorWithMsg;
        }
    }
    throw e;
}
exports.rethrowError = rethrowError;
/**
 * hexlify all members of object, recursively
 * @param obj
 */
function deepHexlify(obj) {
    if (typeof obj === "function") {
        return undefined;
    }
    if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
        return obj;
    }
    else if (obj._isBigNumber != null || typeof obj !== "object") {
        return (0, utils_1.hexlify)(obj).replace(/^0x0/, "0x");
    }
    if (Array.isArray(obj)) {
        return obj.map((member) => deepHexlify(member));
    }
    return Object.keys(obj).reduce((set, key) => (Object.assign(Object.assign({}, set), { [key]: deepHexlify(obj[key]) })), {});
}
exports.deepHexlify = deepHexlify;
// resolve all property and hexlify.
// (UserOpMethodHandler receives data from the network, so we need to pack our generated values)
async function resolveHexlify(a) {
    return deepHexlify(await (0, utils_1.resolveProperties)(a));
}
exports.resolveHexlify = resolveHexlify;
function fillUserOpDefaults(op, defaults = exports.DefaultsForUserOp) {
    const partial = Object.assign({}, op);
    // we want "item:undefined" to be used from defaults, and not override defaults, so we must explicitly
    // remove those so "merge" will succeed.
    for (const key in partial) {
        if (partial[key] == null) {
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete partial[key];
        }
    }
    const filled = Object.assign(Object.assign({}, defaults), partial);
    return filled;
}
exports.fillUserOpDefaults = fillUserOpDefaults;
// helper to fill structure:
// - default callGasLimit to estimate call from entryPoint to account (TODO: add overhead)
// if there is initCode:
//  - calculate sender by eth_call the deployment code
//  - default verificationGasLimit estimateGas of deployment code plus default 100000
// no initCode:
//  - update nonce from account.getNonce()
// entryPoint param is only required to fill in "sender address when specifying "initCode"
// nonce: assume contract as "getNonce()" function, and fill in.
// sender - only in case of construction: fill sender from initCode.
// callGasLimit: VERY crude estimation (by estimating call to account, and add rough entryPoint overhead
// verificationGasLimit: hard-code default at 100k. should add "create2" cost
async function fillUserOp(op, entryPoint, getNonceFunction = "getNonce") {
    var _a;
    const op1 = Object.assign({}, op);
    const provider = entryPoint === null || entryPoint === void 0 ? void 0 : entryPoint.provider;
    if (op.initCode != null) {
        const initAddr = (0, utils_1.hexDataSlice)(op1.initCode, 0, 20);
        const initCallData = (0, utils_1.hexDataSlice)(op1.initCode, 20);
        if (op1.nonce == null)
            op1.nonce = 0;
        if (op1.sender == null) {
            // hack: if the init contract is our known deployer, then we know what the address would be, without a view call
            if (provider == null)
                throw new Error("no entrypoint/provider");
            op1.sender = await entryPoint.callStatic
                .getSenderAddress(op1.initCode)
                .catch((e) => e.errorArgs.sender);
        }
        if (op1.verificationGasLimit == null) {
            if (provider == null)
                throw new Error("no entrypoint/provider");
            const initEstimate = await provider.estimateGas({
                from: entryPoint === null || entryPoint === void 0 ? void 0 : entryPoint.address,
                to: initAddr,
                data: initCallData,
                gasLimit: 10e6,
            });
            op1.verificationGasLimit = ethers_1.BigNumber.from(exports.DefaultsForUserOp.verificationGasLimit).add(initEstimate);
        }
    }
    if (op1.nonce == null) {
        if (provider == null)
            throw new Error("must have entryPoint to autofill nonce");
        const c = new ethers_1.Contract(op.sender, [`function ${getNonceFunction}() view returns(uint256)`], provider);
        op1.nonce = await c[getNonceFunction]().catch((e) => rethrowError(e));
    }
    if (op1.callGasLimit == null && op.callData != null) {
        if (provider == null)
            throw new Error("must have entryPoint for callGasLimit estimate");
        const gasEtimated = await provider.estimateGas({
            from: entryPoint === null || entryPoint === void 0 ? void 0 : entryPoint.address,
            to: op1.sender,
            data: op1.callData,
        });
        // console.log('estim', op1.sender,'len=', op1.callData!.length, 'res=', gasEtimated)
        // estimateGas assumes direct call from entryPoint. add wrapper cost.
        op1.callGasLimit = gasEtimated; // .add(55000)
    }
    if (op1.paymaster != null) {
        if (op1.paymasterVerificationGasLimit == null) {
            op1.paymasterVerificationGasLimit =
                exports.DefaultsForUserOp.paymasterVerificationGasLimit;
        }
        if (op1.paymasterPostOpGasLimit == null) {
            op1.paymasterPostOpGasLimit = exports.DefaultsForUserOp.paymasterPostOpGasLimit;
        }
    }
    if (op1.maxFeePerGas == null) {
        if (provider == null)
            throw new Error("must have entryPoint to autofill maxFeePerGas");
        const block = await provider.getBlock("latest");
        op1.maxFeePerGas = block.baseFeePerGas.add((_a = op1.maxPriorityFeePerGas) !== null && _a !== void 0 ? _a : exports.DefaultsForUserOp.maxPriorityFeePerGas);
    }
    // TODO: this is exactly what fillUserOp below should do - but it doesn't.
    // adding this manually
    if (op1.maxPriorityFeePerGas == null) {
        op1.maxPriorityFeePerGas = exports.DefaultsForUserOp.maxPriorityFeePerGas;
    }
    const op2 = fillUserOpDefaults(op1);
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (op2.preVerificationGas.toString() === "0") {
        // TODO: we don't add overhead, which is ~21000 for a single TX, but much lower in a batch.
        op2.preVerificationGas = callDataCost(encodeUserOp(op2, false));
    }
    return op2;
}
exports.fillUserOp = fillUserOp;
async function fillAndPack(op, entryPoint, getNonceFunction = "getNonce") {
    return packUserOp(await fillUserOp(op, entryPoint, getNonceFunction));
}
exports.fillAndPack = fillAndPack;
async function fillAndSign(op, signer, entryPoint, getNonceFunction = "getNonce") {
    // eslint-disable-next-line no-useless-catch
    try {
        const provider = entryPoint.provider;
        const op2 = await fillUserOp(op, entryPoint, getNonceFunction);
        const chainId = await provider.getNetwork().then((net) => net.chainId);
        const message = (0, utils_1.arrayify)(getUserOpHash(op2, entryPoint.address, chainId));
        let signature;
        try {
            signature = await signer.signMessage(message);
        }
        catch (err) {
            // attempt to use 'eth_sign' instead of 'personal_sign' which is not supported by Foundry Anvil
            signature = await signer._legacySignMessage(message);
        }
        return Object.assign(Object.assign({}, op2), { signature });
    }
    catch (err) {
        throw err;
    }
}
exports.fillAndSign = fillAndSign;
async function fillSignAndPack(op, signer, entryPoint, getNonceFunction = "getNonce") {
    const filledAndSignedOp = await fillAndSign(op, signer, entryPoint, getNonceFunction);
    return packUserOp(filledAndSignedOp);
}
exports.fillSignAndPack = fillSignAndPack;
function callDataCost(data) {
    return ethers_1.ethers.utils
        .arrayify(data)
        .map((x) => (x === 0 ? 4 : 16))
        .reduce((sum, x) => sum + x);
}
exports.callDataCost = callDataCost;
//# sourceMappingURL=ERC4337Utils.js.map